
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { runPythonScript } from "../_shared/python_runner.ts";

// CORS Headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { 
      headers: corsHeaders 
    });
  }

  try {
    // Parse request body
    const { url } = await req.json();
    
    if (!url) {
      return new Response(
        JSON.stringify({ error: "URL is required" }),
        { 
          status: 400,
          headers: { 
            ...corsHeaders,
            "Content-Type": "application/json" 
          } 
        }
      );
    }
    
    console.log(`Starting vulnerability scan for URL: ${url}`);

    // This Python script implements a simplified but functional version of the vulnerability scanner
    const pythonCode = `
import json
import re
import sys
import urllib.parse
import requests
from urllib.parse import urljoin, urlparse

# Configuration
TIMEOUT = 10  # Request timeout in seconds

def is_same_domain(base_url, target_url):
    """Checks if the target URL is within the same domain as the base URL."""
    return urlparse(base_url).netloc == urlparse(target_url).netloc

def normalize_url(base_url, url):
    """Normalizes a URL, joining relative URLs to the base URL."""
    return urljoin(base_url, url)

class SimpleVulnerabilityScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.visited_urls = set()
        self.results = []
        
    def scan(self):
        """Performs a basic vulnerability scan."""
        print(f"Scanning {self.target_url} for vulnerabilities")
        
        try:
            # Basic crawl - just the target URL and any direct links
            self._crawl_limited(self.target_url, depth=1)
            
            # Test for basic vulnerabilities on the found URLs
            for url in self.visited_urls:
                self._test_sql_injection(url)
                self._test_xss(url)
                self._test_csrf(url)
                self._test_directory_traversal(url)
            
            return {
                "status": "completed",
                "target_url": self.target_url,
                "scan_date": "2023-08-01T12:00:00Z",  # Use current date in production
                "total_vulnerabilities": len(self.results),
                "vulnerabilities": self.results
            }
        except Exception as e:
            print(f"Error during scan: {str(e)}")
            return {
                "status": "error",
                "target_url": self.target_url,
                "scan_date": "2023-08-01T12:00:00Z",
                "error": str(e),
                "total_vulnerabilities": 0,
                "vulnerabilities": []
            }
    
    def _crawl_limited(self, url, depth=1):
        """Performs a limited crawl of the website."""
        if depth <= 0 or url in self.visited_urls:
            return
        
        self.visited_urls.add(url)
        
        try:
            response = requests.get(url, timeout=TIMEOUT)
            if not response.ok:
                return
                
            # Extract links with a simple regex (basic approach)
            links = re.findall(r'href=["\'](https?://[^\'"]+)["\']', response.text)
            
            for link in links:
                if is_same_domain(self.target_url, link) and link not in self.visited_urls:
                    self._crawl_limited(link, depth - 1)
                    
        except Exception as e:
            print(f"Error crawling {url}: {str(e)}")
    
    def _test_sql_injection(self, url):
        """Tests for basic SQL injection vulnerabilities."""
        # Only test URLs with parameters
        parsed = urlparse(url)
        if not parsed.query:
            return
            
        query_params = dict(urllib.parse.parse_qsl(parsed.query))
        
        # Basic SQL injection payloads
        payloads = ["'", "1' OR '1'='1", "1; DROP TABLE users"]
        
        for param, value in query_params.items():
            for payload in payloads:
                test_url = url.replace(f"{param}={value}", f"{param}={payload}")
                
                try:
                    response = requests.get(test_url, timeout=TIMEOUT)
                    
                    # Very basic detection - look for SQL error messages
                    if any(error in response.text.lower() for error in 
                           ["sql syntax", "mysql error", "syntax error", "unclosed quotation", "sqlite"]):
                        self.results.append({
                            "type": "SQL Injection",
                            "url": url,
                            "parameter": param,
                            "method": "GET",
                            "payload": payload,
                            "evidence": "Database error message detected",
                            "severity": "High"
                        })
                        break  # Found a vulnerability, no need to test more payloads
                        
                except Exception:
                    pass
    
    def _test_xss(self, url):
        """Tests for basic Cross-Site Scripting vulnerabilities."""
        parsed = urlparse(url)
        if not parsed.query:
            return
            
        query_params = dict(urllib.parse.parse_qsl(parsed.query))
        
        # Basic XSS payloads
        payloads = ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>"]
        
        for param, value in query_params.items():
            for payload in payloads:
                test_url = url.replace(f"{param}={value}", f"{param}={urllib.parse.quote(payload)}")
                
                try:
                    response = requests.get(test_url, timeout=TIMEOUT)
                    
                    # Basic detection - check if our script tag is reflected in the response
                    if payload in response.text:
                        self.results.append({
                            "type": "Cross-Site Scripting (XSS)",
                            "url": url,
                            "parameter": param,
                            "method": "GET",
                            "payload": payload,
                            "evidence": "Reflected XSS payload detected",
                            "severity": "Medium"
                        })
                        break
                        
                except Exception:
                    pass
    
    def _test_csrf(self, url):
        """Tests for basic CSRF vulnerabilities."""
        try:
            response = requests.get(url, timeout=TIMEOUT)
            
            # Look for forms without CSRF tokens
            forms = re.findall(r'<form[^>]*>(.*?)</form>', response.text, re.DOTALL)
            
            for form in forms:
                if 'method="post"' in form.lower() or "method='post'" in form.lower():
                    # Check for CSRF token
                    if not any(token in form.lower() for token in ["csrf", "token", "_token"]):
                        self.results.append({
                            "type": "Cross-Site Request Forgery (CSRF)",
                            "url": url,
                            "parameter": "N/A",
                            "method": "POST",
                            "payload": "N/A",
                            "evidence": "POST form without CSRF token",
                            "severity": "Medium"
                        })
                        
        except Exception as e:
            print(f"Error testing CSRF on {url}: {str(e)}")
    
    def _test_directory_traversal(self, url):
        """Tests for directory traversal vulnerabilities."""
        parsed = urlparse(url)
        if not parsed.query:
            return
            
        query_params = dict(urllib.parse.parse_qsl(parsed.query))
        
        # Basic directory traversal payloads
        payloads = ["../../../etc/passwd", "..%2f..%2f..%2fetc%2fpasswd", "..\\..\\windows\\win.ini"]
        
        for param, value in query_params.items():
            for payload in payloads:
                test_url = url.replace(f"{param}={value}", f"{param}={payload}")
                
                try:
                    response = requests.get(test_url, timeout=TIMEOUT)
                    
                    # Basic detection - look for common file contents
                    if "root:x:" in response.text or "[extensions]" in response.text:
                        self.results.append({
                            "type": "Directory Traversal",
                            "url": url,
                            "parameter": param,
                            "method": "GET",
                            "payload": payload,
                            "evidence": "System file content detected",
                            "severity": "High"
                        })
                        break
                        
                except Exception:
                    pass

if __name__ == "__main__":
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
        scanner = SimpleVulnerabilityScanner(target_url)
        result = scanner.scan()
        print(json.dumps(result))
    else:
        print(json.dumps({"error": "URL not provided"}))
`;

    // Execute the Python code with the URL as an argument
    const result = await runPythonScript(pythonCode, [url]);
    console.log("Scan completed. Returning results.");
    
    return new Response(result, { 
      headers: { 
        ...corsHeaders,
        "Content-Type": "application/json" 
      } 
    });

  } catch (error) {
    console.error("Error during vulnerability scan:", error);
    
    return new Response(
      JSON.stringify({ 
        error: "Failed to scan the website", 
        details: error.message 
      }),
      { 
        status: 500,
        headers: { 
          ...corsHeaders,
          "Content-Type": "application/json" 
        } 
      }
    );
  }
});
