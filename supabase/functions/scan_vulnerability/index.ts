
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { runPythonScript } from "../_shared/python_runner.ts";

// CORS Headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { 
      headers: corsHeaders 
    });
  }

  try {
    // Parse request body
    const { url } = await req.json();
    
    if (!url) {
      return new Response(
        JSON.stringify({ error: "URL is required" }),
        { 
          status: 400,
          headers: { 
            ...corsHeaders,
            "Content-Type": "application/json" 
          } 
        }
      );
    }
    
    console.log(`Starting vulnerability scan for URL: ${url}`);

    // Create a simplified version of the Python script for demonstration purposes
    // In a real implementation, you would properly integrate the full script
    const pythonCode = `
import json
import re
from urllib.parse import urlparse

def simulate_vulnerability_scan(url):
    """Simulates a vulnerability scan for demonstration purposes"""
    parsed_url = urlparse(url)
    
    # This is a simulation - in production this would execute the full scan logic
    results = [
        {
            "type": "SQL Injection",
            "url": url,
            "parameter": "id",
            "method": "GET",
            "payload": "'",
            "evidence": "Simulated detection - database error messages found",
            "severity": "High"
        },
        {
            "type": "Cross-Site Scripting (XSS)",
            "url": url,
            "parameter": "search",
            "method": "GET",
            "payload": "<script>alert('XSS')</script>",
            "evidence": "Simulated detection - script executed",
            "severity": "Medium"
        },
        {
            "type": "Cross-Site Request Forgery (CSRF)",
            "url": f"{url}/login",
            "parameter": "N/A",
            "method": "POST",
            "payload": "N/A",
            "evidence": "Simulated detection - no CSRF token",
            "severity": "Medium"
        },
        {
            "type": "Directory Traversal",
            "url": url,
            "parameter": "file",
            "method": "GET",
            "payload": "../../../etc/passwd",
            "evidence": "Simulated detection - sensitive file accessed",
            "severity": "High"
        }
    ]
    
    # In a real implementation, this would have actual logic to detect vulnerabilities
    return {
        "status": "completed",
        "target_url": url,
        "scan_date": "2023-08-01T12:00:00Z",
        "total_vulnerabilities": len(results),
        "vulnerabilities": results
    }

# Main execution
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        url = sys.argv[1]
        result = simulate_vulnerability_scan(url)
        print(json.dumps(result))
    else:
        print(json.dumps({"error": "URL not provided"}))
`;

    // Execute the Python code with the URL as an argument
    const result = await runPythonScript(pythonCode, [url]);
    console.log("Scan completed. Returning results.");
    
    return new Response(result, { 
      headers: { 
        ...corsHeaders,
        "Content-Type": "application/json" 
      } 
    });

  } catch (error) {
    console.error("Error during vulnerability scan:", error);
    
    return new Response(
      JSON.stringify({ 
        error: "Failed to scan the website", 
        details: error.message 
      }),
      { 
        status: 500,
        headers: { 
          ...corsHeaders,
          "Content-Type": "application/json" 
        } 
      }
    );
  }
});
